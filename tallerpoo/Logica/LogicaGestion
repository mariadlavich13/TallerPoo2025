package tallerpoo.logica;
import tallerpoo.archivos.SistemaGestion;
import tallerpoo.clases.Piloto;
import tallerpoo.clases.Auto;
import tallerpoo.clases.Carrera;
import tallerpoo.clases.AutoPiloto;
import tallerpoo.clases.ResultadoCarrera;
import tallerpoo.archivos.GestorArchivos;
import tallerpoo.clases.Puntaje;
import tallerpoo.clases.Escuderia;
import tallerpoo.clases.Mecanico;
import tallerpoo.clases.PilotoEscuderia;
import tallerpoo.logica.Utilidades;

public class LogicaGestion {
    /**
    /**
     *Asocia piloto a auto en una carrera.
     * Verifica que no haya duplicados.
     * @return El objeto AutoPiloto creado si la asignación es exitosa.
     * @throws LogicaException Si el auto o el piloto ya están asignados en esa carrera.
     */
    public AutoPiloto asociarPilotoAutoACarrera(Carrera carrera, Piloto piloto, Auto auto, String fechaAsignacion) throws LogicaException {
        
        // Verifica que un auto no sea asignado a más de un piloto en la misma carrera
        for (AutoPiloto participante : carrera.getParticipantes()) {
            if (participante.getAuto().equals(auto)) {
                throw new LogicaException("El auto " + auto.getModelo() + " ya está asignado a otro piloto en esta carrera.");
            }
        }
        
        // Verifica que un piloto no esté asignado a más de un auto en la misma carrera
        for (AutoPiloto participante : carrera.getParticipantes()) {
            if (participante.getPiloto().equals(piloto)) {
                throw new LogicaException("El piloto " + piloto.getNombre() + " ya está participando con otro auto en esta carrera.");
            }
        }

        // Si pasa la verificación, crea la asociación
        AutoPiloto nuevaASociacion = new AutoPiloto(fechaAsignacion, piloto, auto, carrera);
        
        // Guarda la asignación en Persistencia
        carrera.agregarParticipante(nuevaASociacion);
        piloto.agregarAutoPiloto(nuevaASociacion);
        auto.agregarAutoPiloto(nuevaASociacion);
        
        return nuevaAsociacion; // Devolvemos el objeto creado
    }

    /**
     * Registra el resultado final de un piloto en una carrera.
     * Esto guarda el resultado y actualiza las estadísticas del piloto.
     *
     * @param datos El sistema de gestión con todas las listas.
     * @param carrera La carrera que finalizó.
     * @param piloto El piloto que obtuvo el resultado.
     * @param posicion La posición final (1, 2, 3...).
     * @param tuvoVueltaRapida true si este piloto hizo la vuelta rápida, false si no.
     */
    public void registrarResultado(SistemaGestion datos, Carrera carrera, Piloto piloto, int posicion, boolean tuvoVueltaRapida) throws LogicaException {
        
        //Validaciones
        if (posicion < 1) {
            throw new LogicaException("La posición debe ser mayor o igual a 1.");
        }
        //¿El piloto realmente participó en la carrera?
        boolean participo = false;
        for (AutoPiloto ap : carrera.getParticipantes()) {
            if (ap.getPiloto().equals(piloto)) {
                participo = true;
                break;
            }
        }
        if (!participo) {
            throw new LogicaException("El piloto " + piloto.getNombre() + " no participó en esta carrera.");
        }
        
        //¿Ya existe un resultado para este piloto en esta carrera?
        for (ResultadoCarrera r : datos.getResultadosCarreras()) {
            if (r.getCarrera().equals(carrera) && r.getPiloto().equals(piloto)) {
                throw new LogicaException("El piloto " + piloto.getNombre() + " ya tiene un resultado registrado para esta carrera.");
            }
        }

        // Crear y guardar el objeto resultado
        ResultadoCarrera resultado = new ResultadoCarrera(piloto, posicion, carrera);
        datos.agregarResultadoCarrera(resultado);

        //Actualizar estadísticas del Piloto
        if (posicion == 1) {
            piloto.setVictorias(piloto.getVictorias() + 1);
        }
        if (posicion <= 3) {
            piloto.setPodios(piloto.getPodios() + 1);
        }  
        if (tuvoVueltaRapida) {
            piloto.setVueltasRapidas(piloto.getVueltasRapidas() + 1);
        }

        //Guardar en el archivo CSV
        String pathResultados = "Datos/DatosResultadoCarrera.csv";
        GestorArchivos.escribirResultadoCSV(pathResultados, resultado);
    }
    /**
     * Calcula el puntaje total de todos los pilotos basado en los resultados de todas las carreras.
     *
     * @param datos El objeto SistemaGestion que contiene todas las listas.
     * @return Una lista de objetos PilotoPuntaje, ordenada de mayor a menor puntaje.
     */
    public List<PilotoPuntaje> calcularPuntajes(SistemaGestion datos) {
        
        List<PilotoPuntaje> puntajesFinales = new ArrayList<>();
        List<Piloto> todosLosPilotos = datos.getPilotos();
        List<ResultadoCarrera> todosLosResultados = datos.getResultadosCarreras();

        // Bucle exterior: Itera sobre cada piloto
        for (Piloto piloto : todosLosPilotos) {
            
            int puntajeTotalDelPiloto = 0; // Inicia el contador para este piloto

            // Bucle interior: Itera sobre todos los resultados de todas las carreras
            for (ResultadoCarrera resultado : todosLosResultados) {
                
                // Comprueba si el resultado pertenece al piloto actual
                // (Comparamos por DNI por seguridad)
                if (resultado.getPiloto().getDni().equals(piloto.getDni())) {
                    
                    // Obtiene los puntos para esa posición
                    int puntosObtenidos = Puntaje.obtenerPuntaje(resultado.getPosicion());
                    
                    // Los suma al total del piloto
                    puntajeTotalDelPiloto += puntosObtenidos;
                }
            }

            // Una vez contados todos los resultados, crea el objeto contenedor
            PilotoPuntaje pp = new PilotoPuntaje(piloto, puntajeTotalDelPiloto);
            puntajesFinales.add(pp);
        }

        return puntajesFinales;
    }



    /**Asocia un piloto a una escudería en un período de tiempo.
     * Verifica que el piloto no tenga ya un contrato activo (sin 'hastaFecha') con otra escudería.
     *
     * @param piloto El piloto a asociar.
     * @param escuderia La escudería a la que se une.
     * @param desdeFecha La fecha de inicio del contrato (ej. "01/01/2025").
     * @return El objeto de asociación PilotoEscuderia creado.
     * @throws LogicaException Si el piloto ya tiene un contrato activo.
     */
    /**
     *Asocia piloto a auto en una carrera.
     */
    public AutoPiloto asociarPilotoAutoACarrera(Carrera carrera, Piloto piloto, Auto auto, String fechaAsignacion) throws LogicaException {
        
        for (AutoPiloto participante : carrera.getParticipantes()) {
            if (participante.getAuto().equals(auto)) {
                throw new LogicaException("El auto " + auto.getModelo() + " ya está asignado a otro piloto en esta carrera.");
            }
        }
        
        for (AutoPiloto participante : carrera.getParticipantes()) {
            if (participante.getPiloto().equals(piloto)) {
                throw new LogicaException("El piloto " + piloto.getNombre() + " ya está participando con otro auto en esta carrera.");
            }
        }

        AutoPiloto nuevaASociacion = new AutoPiloto(fechaAsignacion, piloto, auto, carrera);
        carrera.agregarParticipante(nuevaASociacion);
        piloto.agregarAutoPiloto(nuevaASociacion);
        auto.agregarAutoPiloto(nuevaASociacion);
        
        return nuevaASociacion;
    }

    /**
     * Asocia un piloto a una escudería, validando fechas.
     */
    public PilotoEscuderia asociarPilotoAEscuderia(Piloto piloto, Escuderia escuderia, String desdeFecha) throws LogicaException {
        
        //Usamos la utilidad para formatear
        String nuevaFechaInicioF = Utilidades.formatearFecha(desdeFecha);
        String ultimaFechaFinF = "0000-00-00"; 

        for (PilotoEscuderia pe : piloto.getPilotosEscuderias()) {
            String hastaFecha = pe.getHastaFecha();

            if (hastaFecha == null || hastaFecha.trim().isEmpty()) {
                throw new LogicaException("El piloto " + piloto.getNombre()
                        + " ya tiene un contrato activo con la escudería " + pe.getEscuderia().getNombre() + ".");
            }

            //Comparamos fechas formateadas
            String finExistenteF = Utilidades.formatearFecha(hastaFecha);
            if (finExistenteF != null && finExistenteF.compareTo(ultimaFechaFinF) > 0) {
                ultimaFechaFinF = finExistenteF;
            }
        }

        //Control de superposición de fechas
        if (nuevaFechaInicioF.compareTo(ultimaFechaFinF) <= 0) {
            throw new LogicaException("La fecha de inicio (" + desdeFecha + ") se superpone con un contrato anterior."
                    + " Debe ser posterior a " + ultimaFechaFinF + " (formato YYYY-MM-DD).");
        }

        PilotoEscuderia nuevaAsociacion = new PilotoEscuderia(desdeFecha, "", piloto, escuderia);
        piloto.agregarPilotoEscuderia(nuevaAsociacion);
        escuderia.agregarPilotoEscuderia(nuevaAsociacion);

        return nuevaAsociacion;
    }

    /**
     * Termina el contrato de un piloto con una escudería, asignando "hastaFecha".
     *
     * @param piloto El piloto a desvincular.
     * @param escuderia La escudería de la que se desvincula.
     * @param hastaFecha La fecha de fin de contrato (ej. "31/12/2025").
     * @throws LogicaException Si no se encuentra un contrato activo entre ambos.
     */
    /**
     * Termina el contrato de un piloto, validando fechas.
     */
    public void desvincularPilotoDeEscuderia(Piloto piloto, Escuderia escuderia, String hastaFecha) throws LogicaException {
        
        PilotoEscuderia asociacionActiva = null;
        for (PilotoEscuderia pe : piloto.getPilotosEscuderias()) {
            String hf = pe.getHastaFecha();
            if (pe.getEscuderia().equals(escuderia) && (hf == null || hf.trim().isEmpty())) {
                asociacionActiva = pe;
                break;
            }
        }

        if (asociacionActiva != null) {
            //Validamos que la fecha de fin sea posterior a la de inicio
            String nuevaFechaFinF = Utilidades.formatearFecha(hastaFecha);
            String fechaInicioActivoF = Utilidades.formatearFecha(asociacionActiva.getDesdeFecha());

            if (nuevaFechaFinF.compareTo(fechaInicioActivoF) < 0) {
                throw new LogicaException("La fecha de fin (" + hastaFecha + ") no puede ser anterior a la fecha de inicio (" + asociacionActiva.getDesdeFecha() + ").");
            }
            
            asociacionActiva.setHastaFecha(hastaFecha);
        } else {
            throw new LogicaException("El piloto " + piloto.getNombre()
                    + " no tiene un contrato activo con " + escuderia.getNombre() + ".");
        }
    }

    /**
     * Asocia un auto a una escudería.
     * CONTROL: Verifica que el auto no pertenezca ya a otra escudería.
     *
     * @param auto El auto a asignar.
     * @param escuderia La escudería propietaria.
     * @throws LogicaException Si el auto ya tiene dueña.
     */
    public void asociarAutoAEscuderia(Auto auto, Escuderia escuderia) throws LogicaException {
        
        // Control: Un auto solo puede pertenecer a una escudería a la vez
        if (auto.getEscuderia() != null) {
            throw new LogicaException("El auto " + auto.getModelo()
                    + " ya pertenece a la escudería " + auto.getEscuderia().getNombre() + ".");
        }

        // El método agregarAuto de Escuderia ya maneja la relación bidireccional
        // (internamente hace a.setEscuderia(this) para mantener la coherencia y setea la escudería al auto)
        escuderia.agregarAuto(auto);
    }

    /**
     * Asocia un mecánico a una escudería
     * Control: Verifica que el mecánico no esté ya asignado a esa escudería.
     *
     * @param mecanico El mecánico a contratar.
     * @param escuderia La escudería que contrata.
     * @throws LogicaException Si el mecánico ya trabaja en esa escudería.
     */
    public void asociarMecanicoAEscuderia(Mecanico mecanico, Escuderia escuderia) throws LogicaException {
        
        // Control: Evitar duplicados en la relación muchos a muchos
        if (escuderia.getMecanicos().contains(mecanico)) {
            throw new LogicaException("El mecánico " + mecanico.getNombre()
                    + " ya está asignado a " + escuderia.getNombre());
        }

        // Establecemos la relación bidireccional usando los métodos "agregar"
        escuderia.agregarMecanico(mecanico);
        mecanico.agregarEscuderia(escuderia);
    }

}
