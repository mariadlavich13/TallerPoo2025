package tallerpoo.logica;

import tallerpoo.archivos.SistemaGestion;
import tallerpoo.clases.Carrera;
import tallerpoo.clases.ResultadoCarrera;
import tallerpoo.clases.Piloto;
import tallerpoo.clases.Puntaje;
import tallerpoo.clases.Escuderia;
import tallerpoo.clases.Mecanico;
import tallerpoo.clases.Circuito;
import tallerpoo.clases.AutoPiloto;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import tallerpoo.logica.Utilidades;

/**
 * Contiene la lógica de negocio para generar los diferentes informes
 * solicitados por el sistema.
 */
public class LogicaInformes {
    
    /**
     * Obtiene una lista detallada de resultados de carreras dentro de un rango de fechas.
     *
     * @param datos El objeto SistemaGestion que contiene todos los datos.
     * @param fechaDesde La fecha de inicio del rango (formato "dd-MM-yyyy").
     * @param fechaHasta La fecha de fin del rango (formato "dd-MM-yyyy").
     * @return Una lista de ResultadoCarrera, ordenada por fecha y luego por posición.
     */
    public List<ResultadoCarrera> getReporteResultadosPorFechas(SistemaGestion datos, String fechaDesde, String fechaHasta) {
        
        List<ResultadoCarrera> resultadosEnRango = new ArrayList<>();
        //Se llama a la clase de Utilidades
        String fechaDesdeFormateada = Utilidades.formatearFecha(fechaDesde);
        String fechaHastaFormateada = Utilidades.formatearFecha(fechaHasta);

        for (ResultadoCarrera resultado : datos.getResultadosCarreras()) {
            
            Carrera carreraDelResultado = resultado.getCarrera();
            String fechaCarrera = carreraDelResultado.getFechaRealizacion();
            
            //Se llama a la clase de Utilidades
            String fechaCarreraFormateada = Utilidades.formatearFecha(fechaCarrera);

            // Comprobar si las fechas formateadas no son nulas
            if (fechaCarreraFormateada == null || fechaDesdeFormateada == null || fechaHastaFormateada == null) {
                continue; // O manejar como un error
            }

            boolean estaDespuesDeInicio = fechaCarreraFormateada.compareTo(fechaDesdeFormateada) >= 0;
            boolean estaAntesDeFin = fechaCarreraFormateada.compareTo(fechaHastaFormateada) <= 0;
            if (estaDespuesDeInicio && estaAntesDeFin) {
                resultadosEnRango.add(resultado);
            }
        }

        // Ordenar la lista
        Collections.sort(resultadosEnRango, new Comparator<ResultadoCarrera>() {
            @Override
            public int compare(ResultadoCarrera r1, ResultadoCarrera r2) {
                String fecha1 = Utilidades.formatearFecha(r1.getCarrera().getFechaRealizacion());
                String fecha2 = Utilidades.formatearFecha(r2.getCarrera().getFechaRealizacion());
                
                int comparacionFecha = 0;
                if (fecha1 != null && fecha2 != null) {
                    comparacionFecha = fecha1.compareTo(fecha2);
                }
                
                 if (comparacionFecha != 0) {
                    return comparacionFecha;
                } else {
                    // Si las fechas son iguales, ordena por posición
                    return Integer.compare(r1.getPosicion(), r2.getPosicion());
                }
            }
        });
        return resultadosEnRango;
    }

     /**
      * Devuelve el ranking de pilotos ordenado de mayor a menor puntaje.
      * Llama a LogicaGestion.calcularPuntajes y luego ordena el resultado.
      *
      * @param datos El objeto SistemaGestion (para los datos).
      * @param logicaGestion El objeto LogicaGestion (para el cálculo).
      * @return Una lista de PilotoPuntaje ordenada.
      */
    public List<PilotoPuntaje> getRankingPilotos(SistemaGestion datos, LogicaGestion logicaGestion) {
        
        //Llama al método de LogicaGestion para "Calcular"
        List<PilotoPuntaje> puntajesSinOrdenar = logicaGestion.calcularPuntajes(datos);
        
        //Este método se encarga de "Rankear" (Ordenar)
        // Usa el compareTo que definiste en PilotoPuntaje
        Collections.sort(puntajesSinOrdenar);
        
        //Devuelve la lista ordenada
        return puntajesSinOrdenar;
    }

    /**
     * Calcula la cantidad de veces que un piloto específico corrió en un circuito determinado.
     *
     * @param datos El objeto SistemaGestion que contiene la lista de todas las carreras.
     * @param pilotoBuscado El piloto a consultar.
     * @param circuitoBuscado El circuito a consultar.
     * @return El número de carreras (int) que el piloto corrió en ese circuito.
     */
    public int getContadorPilotoEnCircuito(SistemaGestion datos, Piloto pilotoBuscado, Circuito circuitoBuscado) {
        
        int contador = 0;
        List<Carrera> todasLasCarreras = datos.getCarreras();

        for (Carrera carrera : todasLasCarreras) {
            
            //Verificamos si esta carrera es en el circuito que buscamos
            if (carrera.getCircuito() != null && carrera.getCircuito().equals(circuitoBuscado)) {
                
                //Si es en el circuito correcto, revisamos los participantes
                List<AutoPiloto> participantesDeLaCarrera = carrera.getParticipantes();
                for (AutoPiloto participante : participantesDeLaCarrera) {
                    
                    //Verificamos si el piloto que buscamos está en esa lista
                    if (participante.getPiloto() != null && participante.getPiloto().equals(pilotoBuscado)) {
                        contador++;
                        // Como un piloto solo corre una vez por carrera, salimos de este bucle
                        break;
                    }
                }
            }
        }
        return contador;
    }

    /**
     * Obtiene las estadísticas de un piloto específico.
     *
     * @param datos El SistemaGestion.
     * @param dni El DNI del piloto a buscar.
     * @return El objeto Piloto si se encuentra, o null si no.
     */
    public Piloto getEstadisticasPiloto(SistemaGestion datos, String dni) {
        for (Piloto p : datos.getPilotos()) {
            if (p.getDni().equals(dni)) {
                return p; // Devuelve el piloto encontrado
            }
        }
        return null; // Si no se encuentra
    }

    /**
     * Obtiene el histórico de estadísticas de todos los pilotos.
     *
     * @param datos El SistemaGestion.
     * @return La lista de todos los pilotos (que contienen sus propias estadísticas).
     */
    public List<Piloto> getEstadisticasTodosLosPilotos(SistemaGestion datos) {
        // Simplemente devuelve la lista que ya tiene el sistema
        return datos.getPilotos();
    }

    /**
     * Genera un informe de autos utilizados por escudería en diferentes carreras.
     *
     * @param datos El SistemaGestion.
     * @return Una lista de todos los AutoPiloto registrados, ordenada por escudería y fecha.
     */
    public List<AutoPiloto> getReporteAutosPorEscuderia(SistemaGestion datos) {
        
        List<AutoPiloto> informeCompleto = new ArrayList<>();
        // Itera sobre todas las carreras
        for (Carrera c : datos.getCarreras()) {
            // Agrega todos los participantes de esa carrera a la lista
            informeCompleto.addAll(c.getParticipantes());
        }

        // Ordenar la lista, por escudería y luego por fecha
        Collections.sort(informeCompleto, new Comparator<AutoPiloto>() {
            @Override
            public int compare(AutoPiloto ap1, AutoPiloto ap2) {
                String escuderia1 = (ap1.getAuto() != null && ap1.getAuto().getEscuderia() != null) ? ap1.getAuto().getEscuderia().getNombre() : "Z/Sin Escuderia";
                String escuderia2 = (ap2.getAuto() != null && ap2.getAuto().getEscuderia() != null) ? ap2.getAuto().getEscuderia().getNombre() : "Z/Sin Escuderia";
                
                int compEscuderia = escuderia1.compareTo(escuderia2);
                if (compEscuderia != 0) {
                    return compEscuderia;
                }
  
                // Si es la misma escudería, ordena por fecha de carrera
                String fecha1 = Utilidades.formatearFecha(ap1.getCarrera().getFechaRealizacion());
                String fecha2 = Utilidades.formatearFecha(ap2.getCarrera().getFechaRealizacion());
                
                if (fecha1 == null && fecha2 == null) return 0;
                if (fecha1 == null) return 1;
                if (fecha2 == null) return -1;
                
                return fecha1.compareTo(fecha2);
            }
        });

        return informeCompleto;
    }

    /**
     * Genera un informe de años de experiencia y especialidad de mecánicos por escudería.
     *
     * @param datos El SistemaGestion.
     * @return La lista de todas las Escuderias (que contienen sus listas de mecánicos).
     */
    public List<Escuderia> getReporteMecanicosPorEscuderia(SistemaGestion datos) {
        // Los datos ya están vinculados, solo devolvemos la lista.
        return datos.getEscuderias();
    }

    /**
     * Cuenta la cantidad de carreras que se corrieron en un circuito determinado.
     *
     * @param datos El SistemaGestion que tiene la lista de carreras.
     * @param circuitoBuscado El objeto Circuito por el cual filtrar.
     * @return Un entero (int) con el total de carreras encontradas.
     */
    public int getContadorCarrerasEnCircuito(SistemaGestion datos, Circuito circuitoBuscado) {
        
        int contador = 0;
        List<Carrera> todasLasCarreras = datos.getCarreras();
        
        for (Carrera carrera : todasLasCarreras) {
            // Comparamos si el circuito de la carrera es el que buscamos
            if (carrera.getCircuito() != null && carrera.getCircuito().equals(circuitoBuscado)) {
                contador++;
            }
        }
        return contador;
    }
}